# Описание проекта и методологии разработки

## **1. Название проекта:** Vector Space (Визуальная песочница линейной алгебры).

## **2. Краткое описание проекта:**
Проект представляет собой интерактивную веб-песочницу для визуализации концепций линейной и аналитической алгебры. Целевая аудитория — студенты, преподаватели и любители математики. Инструмент позволяет манипулировать векторами и матрицами в 2D и 3D, наблюдать за преобразованиями пространства, изучать ключевые понятия, такие как Span, векторное произведение, собственные векторы и базисы, с помощью интуитивно понятного графического интерфейса.

## **3. Методология разработки:**
Проект будет разрабатываться по методологии **GRACE (Graph-RAG Anchored Code Engineering)**. Это означает, что разработка начинается с формализации требований и архитектуры в машиночитаемые XML-файлы, которые служат основой для последующей генерации кода.

### **Структура требований (содержимое `./RequirementsAnalysis.xml`):**
На этом этапе была создана формализованная модель предметной области с использованием нотации **Actor-Action-Goal (AAG)**. Эта модель описывает каждый сценарий взаимодействия в формате: "Кто (Actor) что делает (Action), чтобы достичь какой цели (Goal)".

### **Технологический стек (содержимое `./Technology.xml`):**
Этот этап в методологии GRACE — не просто список технологий. Это создание формализованного, машиночитаемого "контракта", который становится набором жестких правил для ИИ на этапе генерации кода.

Основные задачи и особенности этапа:
1) Определение основных компонентов:
- Язык программирования: Выбор основного языка для проекта (в нашем случае, **TypeScript**).
- Фреймворки: Выбор ключевых фреймворков (например, **React** для интерфейса и **Three.js** для 3D-графики).
- Библиотеки: Выбор дополнительных библиотек для конкретных задач (например, **Zustand** для управления состоянием, **math.js** для математических вычислений, **react-konva** для 2D-рендеринга).
- Инструменты: Выбор инструментов для сборки, тестирования, линтинга и т.д. (например, **Vite**, **ESLint**).
2) Ключевая особенность GRACE — "Контракт для ИИ":
В отличие от традиционного подхода, где выбор стека часто остается на уровне "будем использовать React и TypeScript", здесь вы предоставляете явные, точные и детальные инструкции. Это необходимо, чтобы избежать "галлюцинаций" ИИ и обеспечить предсказуемый результат.
- Жесткая версионность: Вместо того чтобы указывать просто "TypeScript", вы должны явно прописать "**TypeScript версии 5.6.2**". Это исключает риск использования ИИ устаревших или несовместимых синтаксических конструкций.
- Совместимость API: Вы не просто перечисляете библиотеки, а определяете их совместимость. Например, вы можете явно указать, что **React 19.0.0** должен использоваться с **@react-three/fiber 8.16.8**. Это предотвращает конфликты зависимостей и ошибки, которые могут возникнуть из-за несовместимых версий.
- Контекст и цели: Вы можете добавить комментарии или метаданные, объясняющие, почему был выбран тот или иной инструмент (например, "**используем Vite как инструмент сборки, так как он обеспечивает быструю горячую перезагрузку (HMR)**"). Это помогает ИИ лучше понять контекст и генерировать более качественный, соответствующий требованиям код.

### **Проектирование архитектурного каркаса (cодержимое `./DevelopmentPlan.xml`):**
На основе предыдущих шагов был создан детальный "чертеж" системы — DevelopmentPlan.xml. На этом этапе применяются "нечеловеческие" методы программирования, и ИИ выполняет "мыслительные тесты" для проверки ключевых алгоритмов. Этот этап — сердце методологии GRACE. Здесь ИИ, опираясь на формализованные требования (RequirementsAnalysis.xml) и выбранные технологии (Technology.xml), создает детальный "чертеж" будущей системы. Это не просто высокоуровневая схема, а полный и подробный план, который будет использован для пошаговой генерации кода.

Что входит в архитектурный каркас:
1) Структура проекта: ИИ определяет иерархию папок и файлов, разделение на модули (например, auth/, products/, orders/). Это обеспечивает организацию и чистоту кода с самого начала.
2) Контракты компонентов: Для каждого файла, класса, функции и метода определяется их "контракт". Это включает в себя:
- Назначение: Четкое описание цели компонента.
- Входные параметры: Типы и названия всех аргументов.
- Возвращаемые значения: Типы и возможные значения результата.
3) Дата-модели: Определяются структуры данных, которые будут использоваться в системе. ИИ связывает эти модели с требованиями и технологическим стеком, чтобы убедиться, что они соответствуют задуманному.

**"Нечеловеческие" техники программирования**

Это одна из самых уникальных особенностей GRACE. ИИ генерирует код, используя подходы, которые не всегда характерны для человеческого программиста, потому что они максимально предсказуемы и облегчают автоматическую генерацию и верификацию.

### **Детерминированная генерация кода:**
ИИ строго следует утвержденному плану (DevelopmentPlan.xml) и использует семантические шаблоны для генерации кода. Каждый файл, класс и функция создаются в соответствии с контрактами, определенными в плане.
Этот этап — кульминация всего процесса. После того как вы и ИИ создали и утвердили подробный "чертеж" проекта (DevelopmentPlan.xml), начинается собственно генерация кода. Ключевое слово здесь — «детерминированная». Это означает, что процесс является не случайным, а предсказуемым. Если вы дважды запустите генерацию с одним и тем же планом, вы получите идентичный результат.

Как это работает?

В отличие от простых LLM, которые генерируют код по свободному запросу (что часто приводит к «галлюцинациям» и неточностям), в GRACE ИИ не «придумывает» код. Он строго следует утвержденному контракту.

1) Входные данные: ИИ получает файл DevelopmentPlan.xml, который содержит все необходимые инструкции:
- Какие классы и методы создать.
- Какие у них входные и выходные параметры.
- Какие условия (например, ошибки) нужно обработать с помощью явных возвратов.
- Какое имя у каждого файла и модуля.
2) Семантические шаблоны: Для обеспечения консистентности и соблюдения стандартов кодирования используются семантические шаблоны. Это не просто блоки кода, а заранее определенные структуры, которые показывают ИИ, как должен выглядеть и как должен быть оформлен сгенерированный код. Например, шаблон может определять:
- Формат docstring для каждой функции.
- Правила именования переменных и классов.
- Стандартную структуру для обработки явных возвратов (например, return (status, data)).
3) Пошаговая генерация: ИИ работает как конвейер. Он берет каждый компонент из DevelopmentPlan.xml и, используя технологический стек (Technology.xml) и семантические шаблоны, «заполняет» его логикой. Например, для метода register_user, ИИ:
- Создает функцию с правильным именем и параметрами.
- Генерирует код для валидации данных, используя библиотеки, указанные в Technology.xml.
- Вставляет логику для сохранения пользователя в базу данных.
- Использует паттерн явных возвратов, чтобы вернуть Success или UsernameTaken, в зависимости от результата.

**Ключевые преимущества этого подхода:**
- Высокая предсказуемость: Вы заранее знаете, как будет выглядеть и работать код, потому что он является точным воплощением вашего архитектурного плана.
- Минимальное количество ошибок: Поскольку ИИ не «изобретает» велосипед, а строго следует проверенному контракту, риск логических ошибок и несовместимости сводится к минимуму.
- Кодовая база с единым стилем: Все сгенерированные файлы имеют одинаковую структуру, форматирование и соответствуют единым стандартам, что делает код чистым и легко читаемым.
- Сверхвысокая скорость: Самая трудоемкая часть разработки — написание рутинного кода по заранее известным правилам — полностью автоматизируется, высвобождая время для решения по-настоящему сложных и творческих задач.


### **Верификация и сопровождение:**
Сгенерированный код проверяется с помощью структурированных логов. Если обнаруживаются отклонения, начинается новый цикл доработок, начиная с соответствующего этапа.
Верификация и сопровождение
Этот этап является критически важным завершением цикла, который превращает разовую генерацию кода в устойчивый и поддерживаемый процесс разработки. Здесь главная цель — убедиться, что сгенерированный код точно соответствует задуманному плану, и создать систему для непрерывного улучшения.

1. Верификация (Verification)
Верификация в GRACE — это не просто ручное тестирование. Это автоматизированный процесс, который сравнивает фактическое поведение сгенерированного кода с его архитектурным "контрактом", описанным в DevelopmentPlan.xml.
- Структурированные логи: Ключевым инструментом являются структурированные логи. Вместо неформатированных текстовых сообщений, система генерирует логи в виде машиночитаемых данных (например, JSON или ключ-значение). Каждый лог-файл содержит информацию о конкретном событии, включая его тип, статус, входные данные и результат.

- Пример: При попытке входа пользователя, лог может выглядеть так:

```JSON
{
    "event": "UserLoginAttempt",
    "status": "InvalidCredentials",
    "details": "Password does not match",
    "timestamp": "2025-09-17T14:30:00Z"
}
```
- Автоматический анализ: Система верификации автоматически анализирует эти логи, чтобы убедиться, что каждое событие соответствует одному из ожидаемых исходов, описанных в DevelopmentPlan.xml. Если в плане указано, что login_user может вернуть Success или InvalidCredentials, система проверяет, что логи содержат только эти статусы. Любое отклонение (например, запись об ошибке, не предусмотренной планом) немедленно сигнализирует о проблеме.

2. Сопровождение (Maintenance) и цикл доработок

Когда в процессе верификации обнаруживается отклонение, GRACE не предполагает ручного исправления кода. Вместо этого запускается новый итеративный цикл, который возвращается к источнику проблемы.

- Определение источника проблемы: Система пытается определить, на каком этапе возникло расхождение:

- Проблема в генерации кода: Если DevelopmentPlan.xml был корректен, но ИИ сгенерировал неверный код, система автоматически возвращается к этапу «Детерминированной генерации кода» и предоставляет ИИ более точные инструкции или поправки, чтобы получить правильный результат.

- Проблема в архитектурном плане: Если код работает так, как было написано, но его поведение расходится с изначальными требованиями (например, был пропущен какой-то крайний случай), то система инициирует возврат к этапу «Проектирование архитектурного каркаса». Вы или ИИ вносите правки в DevelopmentPlan.xml, чтобы учесть новый сценарий.

- Проблема в требованиях: В редких случаях, если ошибка связана с неверной или неполной формализацией требований, процесс может вернуться к самому первому этапу «Анализ требований», чтобы внести исправления в RequirementsAnalysis.xml.

**Почему это эффективно?**

Эта модель «фиксируй план, а не код» обеспечивает, что исправления вносятся на самом высоком уровне абстракции. Это не только устраняет текущий баг, но и предотвращает его повторное появление, а также гарантирует, что вся кодовая база остается консистентной и соответствует изначальному архитектурному замыслу. Таким образом, GRACE создает самовосстанавливающуюся систему, которая непрерывно совершенствуется.