# Contract: Vector Store Expression Integration

**Feature**: Dynamic Expression UX (001-dynamic-expression-ux)  
**Contract Version**: 1.0.0  
**Date**: 2025-10-30

## Overview
This contract defines the integration points between the expression handling system and the vector store (zustand). It specifies how expression state, ghost vectors, and vector definitions are managed in the store.

## API Definition

### Interface: VectorStore (Extended)

#### New State Properties

**Property: activeExpression**
- Type: `Expression | null`
- Description: The currently active expression being edited by the user
- Default: `null`

**Property: ghostVectors**
- Type: `GhostVector[]`
- Description: Array of ghost vectors generated by the current expression
- Default: `[]`

**Property: vectorDefinitions**
- Type: `VectorDefinition[]`
- Description: Array of user-defined vectors that can be referenced in expressions
- Default: `[]`

**Property: expressionHistory**
- Type: `Expression[]`
- Description: History of recently used expressions (max 10 items)
- Default: `[]`

#### New Actions

**Action: setActiveExpression**
Updates the active expression and processes it for ghost vectors.

**Input**: 
- `expression: string` - The new expression content

**Side Effects**:
- If expression is valid, parse it and update ghostVectors
- If expression is invalid, clear ghostVectors and store error
- Add expression to expressionHistory (if valid and not duplicate)

**Action: clearActiveExpression**
Clears the active expression and removes associated ghost vectors.

**Input**: None

**Side Effects**:
- Sets activeExpression to null
- Clears ghostVectors array
- Does not affect vectorDefinitions or expressionHistory

**Action: addVectorDefinition**
Adds or updates a vector definition that can be used in expressions.

**Input**:
- `definition: VectorDefinition` - The vector definition to add/update

**Side Effects**:
- Updates vectorDefinitions array
- If there's an active expression, re-parses it to see if new vector enables ghost vectors

**Action: updateVectorDefinition**
Updates an existing vector definition.

**Input**:
- `id: string` - The ID of the vector definition to update
- `updates: Partial<VectorDefinition>` - The properties to update

**Side Effects**:
- Updates the specified vector definition
- If there's an active expression, re-parses it (if it references the updated vector)

**Action: removeVectorDefinition**
Removes a vector definition.

**Input**:
- `id: string` - The ID of the vector definition to remove

**Side Effects**:
- Removes the vector definition
- If active expression referenced the removed vector, clears ghost vectors and marks expression as invalid

## Behavior Contracts

### Contract 1: Expression Processing Flow
**Given**: User enters a valid expression referencing defined vectors (e.g., "v1 + [1,2,3]")
**When**: setActiveExpression is called with the expression
**Then**: 
1. activeExpression is updated with the content and validity information
2. ghostVectors array is populated with appropriate ghost vectors
3. If expression is invalid, ghostVectors is cleared and error is stored

### Contract 2: Real-time Updates
**Given**: An active expression exists with ghost vectors displayed
**When**: A vector definition referenced in the expression is updated via updateVectorDefinition
**Then**: The expression should be re-parsed and ghost vectors updated accordingly

### Contract 3: Expression Clearing
**Given**: An active expression with associated ghost vectors
**When**: clearActiveExpression is called or user clears the input
**Then**: 
1. activeExpression becomes null
2. ghostVectors array is cleared
3. Visual representation of ghost vectors is removed from the scene

### Contract 4: Vector Definition Management
**Given**: The application with existing vector definitions
**When**: addVectorDefinition is called with a new definition
**Then**: 
1. The definition is added to vectorDefinitions array
2. If there's an active expression that references this new vector, it's re-parsed to generate ghost vectors

### Contract 5: Performance Requirements
**Given**: A valid expression that results in ghost vectors
**When**: setActiveExpression is called
**Then**: The operation completes within 100ms, including parsing and ghost vector generation

## State Transition Rules

### Valid Transitions
1. `activeExpression: null` → `activeExpression: Expression` (when user starts typing)
2. `activeExpression: Expression` → `activeExpression: updated Expression` (when user continues typing)
3. `activeExpression: Expression` → `activeExpression: null` (when cleared)
4. `ghostVectors: []` → `ghostVectors: [GhostVector, ...]` (when expression has valid vector operations)
5. `ghostVectors: [GhostVector, ...]` → `ghostVectors: []` (when expression cleared/invalid)

### Constraints
1. ghostVectors should only contain vectors related to the current activeExpression
2. vectorDefinitions names must be unique within the array
3. expressionHistory should not exceed 10 items (remove oldest when adding new)

## Error Handling

### Expected Error States
1. Expression validation errors should be stored in activeExpression.error
2. Vector reference errors should result in invalid expression state
3. Parsing errors should clear ghost vectors

### Error Recovery
1. When an expression becomes invalid, ghost vectors should be cleared
2. User should be able to continue editing to fix the error
3. Valid expressions should re-enable ghost vector visualization

## Integration Points

### With Expression Parser
- VectorStore calls ExpressionParser.parseExpression when setActiveExpression is called
- VectorStore provides vectorDefinitions to ExpressionParser for context

### With UI Components
- ExpressionInputPanel reads activeExpression to display current input
- VectorRenderer reads ghostVectors to display temporary vectors
- ExpressionInputPanel calls setActiveExpression when user types

## Testing Requirements
1. Unit test: setActiveExpression updates state correctly
2. Unit test: clearActiveExpression clears related state
3. Unit test: addVectorDefinition updates vectorDefinitions
4. Integration test: Expression updates trigger proper ghost vector updates
5. Performance test: State updates complete within 100ms
6. Integration test: Vector definition updates re-trigger ghost vector computation